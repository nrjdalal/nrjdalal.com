{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "scripts-build-registry",
  "type": "registry:file",
  "dependencies": ["node:fs", "node:path", "tinyglobby"],
  "files": [
    {
      "type": "registry:file",
      "target": "scripts/build-registry.ts",
      "content": "#!/usr/bin/env node\nimport fs from \"node:fs\"\nimport path from \"node:path\"\nimport { glob } from \"tinyglobby\"\n\nconst config = {\n  files: [\"@/app/globals.css\", \"scripts/build-registry.ts\"],\n  directories: [\"@/components/nui\"],\n}\n\nconst getFiles = async ({\n  patterns = [\"**\", \".**\"],\n  ignore = [] as string[],\n} = {}) => {\n  patterns = Array.isArray(patterns) ? patterns : [patterns]\n  ignore = Array.isArray(ignore) ? ignore : [ignore]\n\n  if (fs.existsSync(\".gitignore\")) {\n    const gitignorePatterns: string[] = (\n      await fs.promises.readFile(\".gitignore\", \"utf8\")\n    )\n      .split(\"\\n\")\n      .map((line) => line.trim())\n      .filter((line) => line && !line.startsWith(\"#\"))\n      .map((line) => line.replace(/^\\//, \"\"))\n    ignore = ignore.concat(gitignorePatterns)\n  }\n\n  return await glob(patterns, {\n    ignore: ignore.filter((ig) => !patterns.includes(ig)),\n  })\n}\n\nconst normalizeAndFilter = ({\n  paths = [],\n  directory = false,\n  aliases = {},\n  files = [],\n}: {\n  paths: string[]\n  directory?: boolean\n  aliases?: Record<string, string>\n  files?: string[]\n}): string[] => {\n  return paths\n    .map((path) => {\n      path = path.replace(/^\\.\\//, \"\")\n      for (const alias in aliases) {\n        if (path.startsWith(alias)) {\n          return path.replace(alias, aliases[alias])\n        }\n      }\n      return path\n    })\n    .filter((path) => {\n      if (directory) {\n        return files.some((file) => file.startsWith(path))\n      } else {\n        return files.includes(path)\n      }\n    })\n}\n\nconst getAliases = async () => {\n  const isTypescript = fs.existsSync(\"tsconfig.json\")\n\n  if (isTypescript) {\n    const tsconfig = await fs.promises.readFile(\"tsconfig.json\", \"utf8\")\n    const { compilerOptions } = JSON.parse(tsconfig)\n    if (compilerOptions && compilerOptions.paths) {\n      return Object.entries(\n        compilerOptions.paths as Record<string, [string]>,\n      ).reduce(\n        (acc, [key, [value]]) => {\n          acc[key.replace(/\\*$/, \"\")] = value\n            .replace(/^\\.\\//, \"\")\n            .replace(/\\*$/, \"\")\n          return acc\n        },\n        {} as Record<string, string>,\n      )\n    }\n  }\n\n  return {}\n}\n\nconst files = await getFiles()\nconst aliases = await getAliases()\n\nconst normalizedConfig = {\n  files: normalizeAndFilter({\n    paths: config.files,\n    files,\n    aliases,\n  }),\n  directories: normalizeAndFilter({\n    paths: config.directories,\n    files,\n    aliases,\n    directory: true,\n  }),\n}\n\nconst configFiles = [\n  ...normalizedConfig.files,\n  ...files.filter((file) =>\n    normalizedConfig.directories.some((directory) =>\n      file.startsWith(directory),\n    ),\n  ),\n]\n\nconst getImports = async ({ filePath }: { filePath: string }) => {\n  const content: Record<string, string> = {}\n\n  const data: { dependencies: string[]; files: string[] } = {\n    dependencies: [],\n    files: [],\n  }\n\n  const fileContent = content[filePath] || fs.readFileSync(filePath, \"utf-8\")\n  content[filePath] = fileContent\n\n  const importStatements = fileContent.match(\n    /import\\s+.*\\s+from\\s+['\"].*['\"]|import\\s+['\"].*['\"]/g,\n  )\n\n  if (!importStatements) {\n    data.files.push(filePath)\n    content[filePath] = fileContent\n    return { data, content }\n  }\n\n  const importFroms = importStatements\n    .map((statement) => {\n      const match = statement.match(/['\"](.*)['\"]/)\n      return match ? match[1] : null\n    })\n    .filter((importFrom): importFrom is string => Boolean(importFrom))\n\n  for (const importFrom of importFroms) {\n    const aliasKey = Object.keys(aliases).find((key) =>\n      importFrom.startsWith(key),\n    )\n    if (aliasKey) {\n      let resolvedPath = path.join(\n        aliases[aliasKey],\n        importFrom.slice(aliasKey.length),\n      )\n      resolvedPath =\n        files.find((file) => file.startsWith(resolvedPath + \".\")) || \"\"\n      if (!data.files.includes(resolvedPath)) {\n        data.files.push(resolvedPath)\n      }\n    } else if (importFrom.startsWith(\".\")) {\n      let resolvedPath = path.join(path.dirname(filePath), importFrom)\n      resolvedPath = files.find((file) => file.startsWith(resolvedPath)) || \"\"\n      if (!data.files.includes(resolvedPath)) {\n        data.files.push(resolvedPath)\n      }\n    } else {\n      const packageName = importFrom.startsWith(\"@\")\n        ? importFrom.split(\"/\").slice(0, 2).join(\"/\")\n        : importFrom.split(\"/\")[0]\n      if (!data.dependencies.includes(packageName)) {\n        data.dependencies.push(packageName)\n      }\n    }\n  }\n\n  const uniqueFiles = new Set(data.files)\n\n  for (const file of uniqueFiles) {\n    const importsData = await getImports({ filePath: file })\n    content[file] = importsData.content[file]\n    importsData.data.files.forEach((importFile) => uniqueFiles.add(importFile))\n    importsData.data.dependencies.forEach((dependency) => {\n      if (!data.dependencies.includes(dependency)) {\n        data.dependencies.push(dependency)\n      }\n    })\n  }\n\n  data.files = [filePath, ...Array.from(uniqueFiles)]\n\n  return { data, content }\n}\n\nconst normalizeImports = ({\n  imports,\n  aliases,\n}: {\n  imports: {\n    content: Record<string, string>\n    data: {\n      files: string[]\n      dependencies: string[]\n    }\n  }\n  aliases: Record<string, string>\n}) => {\n  const normalizePath = (file: string) => {\n    return file\n      .replace(/^registry\\/default\\/components\\//, \"components/default/\")\n      .replace(/^registry\\/default\\/ui\\//, \"components/ui/\")\n      .replace(/^registry\\/default\\/hooks\\//, \"hooks/\")\n      .replace(/^registry\\/default\\/lib\\//, \"lib/\")\n  }\n\n  const content = Object.fromEntries(\n    Object.entries(imports.content).map(([key, value]) => {\n      const aliasKey = Object.keys(aliases).find((alias) =>\n        key.startsWith(aliases[alias]),\n      )\n      const normalizedKey = aliasKey ? key.replace(aliases[aliasKey], \"\") : key\n      return [normalizePath(normalizedKey), value]\n    }),\n  )\n\n  const target = imports.data.files.map((file: string) =>\n    normalizePath(\n      Object.keys(aliases).reduce(\n        (acc, alias) => acc.replace(aliases[alias], \"\"),\n        file,\n      ),\n    ),\n  )\n\n  return {\n    ...imports,\n    content,\n    data: { ...imports.data, files: target, orignal: imports.data.files },\n  }\n}\n\nfor (const file of configFiles) {\n  const imports = normalizeImports({\n    imports: await getImports({\n      filePath: file,\n    }),\n    aliases,\n  })\n\n  const name = imports.data.files[0]\n    .replace(/^registry\\/default\\/components\\//, \"default/\")\n    .replace(/^registry\\/default\\/ui\\//, \"components/ui/\")\n    .replace(/^registry\\/default\\/hooks\\//, \"hooks/\")\n    .replace(/^registry\\/default\\/lib\\//, \"lib/\")\n    .replace(/^block\\//, \"\")\n    .replace(/^components\\/ui\\//, \"\")\n    .replace(/^components\\//, \"\")\n    .replace(/^hooks\\//, \"\")\n    .replace(/^lib\\//, \"\")\n    .replace(/\\..*$/, \"\")\n    .replace(/\\//g, \"-\")\n\n  const getType = (filePath: string) => {\n    return (\n      filePath\n        .match(/^(block|components\\/ui|components|hooks|lib)/)?.[0]\n        .replace(\"components/ui\", \"registry:ui\")\n        .replace(\"components\", \"registry:component\")\n        .replace(\"hooks\", \"registry:hooks\")\n        .replace(\"lib\", \"registry:lib\")\n        .replace(\"block\", \"registry:block\") || \"registry:file\"\n    )\n  }\n\n  const outputPath = path.join(\"public\", \"r\", `${name}.json`)\n  const outputData = {\n    $schema: \"https://ui.shadcn.com/schema/registry-item.json\",\n    name,\n    type: getType(imports.data.files[0]),\n    dependencies: imports.data.dependencies,\n    files: imports.data.files.map((file) => {\n      return {\n        type: getType(file),\n        target: file,\n        content: imports.content[file],\n        path: imports.data.orignal[imports.data.files.indexOf(file)],\n      }\n    }),\n  }\n\n  fs.mkdirSync(path.dirname(outputPath), { recursive: true })\n  fs.writeFileSync(\n    outputPath,\n    JSON.stringify(outputData, null, 2) + \"\\n\",\n    \"utf-8\",\n  )\n}\n",
      "path": "scripts/build-registry.ts"
    }
  ]
}
